# RPC框架
> 在easy基础上升级了各部分功能，包括全局配置、mock、Spi、注册中心、自定义协议、负载均衡、重试策略、容错策略
> 升级版rpc项目整体上分为三部分:
> 1. 服务提供者: 负责提供接口方法的实现(提供者相对于服务器端，需要实现处理消费者端发过来的请求)
> 2. 服务消费者: 负责调用服务提供者实现的方法(消费者需要向服务提供者发送请求)
> 3. RPC框架: 负责将服务提供者与服务消费者进行通信，并实现服务调用
> 4. 可实现全局配置读取，比如选择哪个序列化接口
> 5. 实现了注解驱动，简化用户操作
![img1.png](doc%2Fimg1.png)
## 项目准备
### 需求分析
1. 服务提供者模块: 服务模块需要实现接口，并实现相关方法，同时需要实现实现类注册，可以根据接口名找到实现类
2. 服务消费者模块: 消费者模块需要向服务提供者发送请求，并获得结果
3. RPC模块:
    - 全局配置功能实现，可以读到全局配置文件
    - mock功能实现
    - Spi扩展功能实现
    - 序列化接口实现，便于扩展不同的序列化方式
    - 局部注册仓库实现，可以让服务提供者注册实现类
    - 注册中心功能实现，服务提供者可以将自己的地址注册到注册中心，让消费者可以找到服务提供者
    - 自定义协议实现
    - 动态代理实现，可以根据动态代理模式实现不同接口的请求发送
    - 请求处理器实现，根据请求信息，找到服务提供者对应的实现类并调用方法，并返回结果
    - 全局配置功能实现，可以读到全局配置文件，再根据配置文件选择哪个序列化接口
    - 重试和容错机制
3. 基于springboot实现注解驱动
### 技术选型
- 局部注册仓库：先用ConcurrentHashMap类实现，可以动态的增删服务提供者，并且线程安全，采用数组 + 链表 + 红黑树的数据结构，
  当链表长度超过一定阈值（默认为 8）且数组长度大于 64 时，链表会转换为红黑树，以提高查找效率；当红黑树节点数小于等于 6 时，会转换回链表。
  java8前采用分段锁，java8及之后就是cas+synchronized，所以线程安全
- 服务器: Etcd 官方文档：https://etcd.io/docs/
    - **简单易用**：Vert.x提供了高层次的抽象，相比Netty框架更简单易用。它不仅仅是一个网络框架，还是一个完整的异步编程框架，提供了包括HTTP服务器/客户端、WebSocket、事件总线、数据库访问、定时器等在内的多种构建高性能应用程序的工具和各种网络编程的API。
    - **高性能**：Vert.x基于事件循环机制，采用单线程或少量线程处理大量并发连接，可以有效减少线程上下文切换的开销，提高服务器的吞吐量和响应速度。更适合RPC框架这种需要处理大量TCP连接的应用场景。
    - **解决半包粘包问题**：对于TCP半包粘包的情况，Vert.x提供了RecordParser类，能更方便地解决，不用自己去设计算法来处理。
- 注册中心: Etcd：社区的生态和活跃度以及性能好，简单易用，功能更符合要求，Lease（租约）：用于对键值对进行TTL超时设置，即设置键值对的过期时间。当租约过期时，相关的键值对将被自动删除。
  Watch（监听）：可以监视特定键的变化，当键的值发生变化时，会触发相应的通知。
- java
- Hutool: https://doc.hutool.cn/pages/index/
- guava-Retrying: 基于线程的重试机制，可以自动重试失败的请求
## 项目实施
### 初始化阶段
1. 创建maven项目
2. 创建几个模块:
    - example-common：代码的公共依赖，包括接口、Model 等
    - example-extended-consumer：服务消费者模块
    - example-extended-provider：服务提供者模块
    - rpc-core：升级版 RPC 框架模块
### example-common开发
> 负责存储服务接口和model
1. 创建一个简单的 User类和UserService接口，给其他模块用
### rpc-core开发
1. 实现全局配置功能，读取配置文件，并返回配置类对象，对象可通过启动类类读取
2. 实现了mock机制，是否开启mock由配置类属性确认
3. 自定义SPI扩展机制，用户可以自定义实现类，通过SpiLoader.load()可以导入实现类
4. 实现序列化接口，以及各种实现类，通过配置类属性确认读取哪个序列化实现类，工厂模式获取实例，工厂模式中通过静态代码块获取所有该接口下的实例
5. 实现注册中心功能
    - 服务注册：服务提供者上报服务信息到注册中心
    - 服务发现：服务消费者从注册中心拉取服务信息
    - 数据分布式存储：集中的注册信息数据存储、读取和共享
    - 心跳检测：定期检查服务提供者的存活状态，如果存活就续期
    - 服务注销：手动剔除节点、或者自动剔除失效节点
    - 在消费端加上本地缓存，用watch监控
6. 实现自定义协议，基于tcp的协议，注意解决粘包半包问题
![img2.png](doc%2Fimg2.png)
7. 实现负载均衡算法
8. 实现重试和容错
9. 实现实现类本地注册，采用conCurrentHashMap方法实现，key为类全限定名，value为实现类，提供对应的register，get，remove方法
10. 实现请求处理器，先设置通用的处理器接口，再实现基于vert.x的请求处理器
11. 实现动态代理，用于生成代理类
### example-provider开发
> 负责实现common中的service接口同时配置服务器
1. 实现UserService接口，并实现相关方法
2. 将方法存到本地服务注册
3. 实现启动类，结合Vert.x服务器
### example-consumer开发
> 负责调用example-provider中实现的服务
1. 使用动态代理技术得到代理类，调用方法
### 全局配置开发
> 负责全局配置，包括注册中心地址、服务接口、序列化方式、网络通信协议、超时设置、负载均衡策略、服务端线程等
1. 实现配置类功能
### mock服务实现
> 创建一个mock服务，用于测试
1. 通过动态代理实现mock服务，可以通过全局配置实现是否开启mock
### 序列化器和SPI机制开发
> 序列化器：负责序列化与反序列化，采用SPI机制实现
### 注册中心开发
> 负责实现注册中心，所有的提供服务者都需要自己注册到注册中心，所有的消费者都需要从注册中心获取服务提供者的地址
> - 数据分布式存储：集中的注册信息数据存储、读取和共享
> - 服务注册：服务提供者上报服务信息到注册中心
> - 服务发现：服务消费者从注册中心拉取服务信息
> - 心跳检测：定期检查服务提供者的存活状态
> - 服务注销：手动剔除节点、或者自动剔除失效节点
> - 更多优化点：比如注册中心本身的容错、服务消费者缓存等。
1. 采用etcd中间件实现注册中心 https://github.com/etcd-io/etcd
2. 安装和测试etcd，确保环境没有问题
3. 实现服务注册、服务发现、服务注销等基础功能
4. 实现心跳检测功能和续期功能
5. 实现服务节点宕机下线机制
6. 加入缓存机制
### 自定义协议开发
> 负责实现自定义协议，比如http、tcp等
1. 实现tcp请求处理器
2. 实现tcp客户端代码
4. 测试
### 负载均衡开发
> 负责实现负载均衡算法，比如随机、轮询、一致性hash等
1. 实现负载均衡算法
2. 实现spi动态加载机制
### 重试机制开发
> 调用接口失败可能有很多原因，有时可能是服务提供者返回了错误，但有时可能只是网络不稳定或
服务提供者重启等临时性问题。这种情况下，我们可能更希望服务消费者拥有自动重试的能力，提
高系统的可用性。
1. 什么时候、什么条件下重试
2. 重试时间（确定下一次的重试时间）
3. 什么时候、什么条件下停止重试？
4. 重试后要做什么？
### 容错机制开发
> 重试机制也算容错机制的一种，只不过容错机制更全面，提供了更多的容错机制，像服务降级，服务熔断等。
1. 实现了服务降级
2. 实现了服务静默
3. spi机制
### 框架优化
> 优化rpc框架，加入一些容易上手的启动机制和注解驱动方法
1. 在原有的基础上加入springboot框架
2. 实现自己的注解类,@Enable表示开启rpc框架，@RpcReference表示注入服务，@RpcService表示注册服务

