# RPC框架具体流程
> rpc项目整体上分为三部分: 
> 1. 服务提供者: 负责实现服务接口的实现
> 2. 服务消费者: 负责调用服务提供者的服务
> 3. RPC框架: 负责将服务提供者与服务消费者进行通信，并实现服务调用
> 本项目分成二个阶段，先初步实现基础的rpc框架，让rpc之间实现通信等基础的功能，将这部分放到easy模块中，然后在easy模块的基础上进行core模块的开发，core模块将优化eays模块，实现包括服务注册、服务发现、服务调用等。
## 项目准备
### 需求分析
1. 实现rpc框架，要求能够实现服务注册、服务发现、服务调用等功能
2. 在基础功能上实现一些扩展操作，比如负载均衡、容错处理、服务监控等
### 技术选型
- 服务器端: Vert.x 官方文档：https://vertx.io/
- 注册中心: Etcd 官方文档：https://etcd.io/docs/
- java
- Hutool: https://doc.hutool.cn/pages/index/
## 项目实施
### 初始化阶段
1. 创建几个模块:
    - example-common：示例代码的公共依赖，包括接口、Model 等
    - example-consumer：示例服务消费者代码
    - example-provider：示例服务提供者代码
    - rpc-easy：简易版 RPC 框架
2. 创建一个简单的 User类和接口，实现模块间的互通
### example-common开发
> 负责存储服务接口和model
1. 创建一个简单的 User类和UserService接口，给其他模块用
### rpc-easy开发
> 负责实现rpc框架，包括服务本地注册，请求处理器，动态代理，序列化方法等
1. 实现服务本地注册，采用conCurrentHashMap方法实现，key为类全限定名，value为实现类
2. 实现请求处理器，先设置通用的处理器接口，再实现基于vert.x的请求处理器
3. 实现序列化接口，便于扩展不同的序列化
4. 实现动态代理，用于生成代理类
### example-provider开发
> 负责实现common中的service接口同时配置服务器
1. 实现UserService接口，并实现相关方法
2. 将方法存到本地服务注册
3. 实现启动类，结合Vert.x服务器
### example-consumer开发
> 负责调用example-provider中实现的服务
1. 使用动态代理技术得到代理类，调用方法
### 全局配置开发
> 负责全局配置，包括注册中心地址、服务接口、序列化方式、网络通信协议、超时设置、负载均衡策略、服务端线程等
1. 实现配置类功能
### mock服务实现
> 创建一个mock服务，用于测试
1. 通过动态代理实现mock服务，可以通过全局配置实现是否开启mock
### 序列化器和SPI机制开发
> 序列化器：负责序列化与反序列化，采用SPI机制实现
### 注册中心开发
> 负责实现注册中心，所有的提供服务者都需要自己注册到注册中心，所有的消费者都需要从注册中心获取服务提供者的地址
> - 数据分布式存储：集中的注册信息数据存储、读取和共享
> - 服务注册：服务提供者上报服务信息到注册中心
> - 服务发现：服务消费者从注册中心拉取服务信息
> - 心跳检测：定期检查服务提供者的存活状态
> - 服务注销：手动剔除节点、或者自动剔除失效节点
> - 更多优化点：比如注册中心本身的容错、服务消费者缓存等。
1. 采用etcd中间件实现注册中心 https://github.com/etcd-io/etcd
2. 安装和测试etcd，确保环境没有问题
3. 实现服务注册、服务发现、服务注销等基础功能
4. 实现心跳检测功能和续期功能
5. 实现服务节点宕机下线机制
6. 加入缓存机制
### 自定义协议开发
> 负责实现自定义协议，比如http、tcp等
1. 实现tcp请求处理器
2. 实现tcp客户端代码
4. 测试
### 负载均衡开发
> 负责实现负载均衡算法，比如随机、轮询、一致性hash等
1. 实现负载均衡算法
2. 实现spi动态加载机制
### 重试机制开发
> 调用接口失败可能有很多原因，有时可能是服务提供者返回了错误，但有时可能只是网络不稳定或
服务提供者重启等临时性问题。这种情况下，我们可能更希望服务消费者拥有自动重试的能力，提
高系统的可用性。
1. 什么时候、什么条件下重试
2. 重试时间（确定下一次的重试时间）
3. 什么时候、什么条件下停止重试？
4. 重试后要做什么？
### 容错机制开发
> 重试机制也算容错机制的一种，只不过容错机制更全面，提供了更多的容错机制，像服务降级，服务熔断等。
1. 实现了服务降级
2. 实现了服务静默
3. spi机制
### 框架优化
> 优化rpc框架，加入一些容易上手的启动机制和注解驱动方法
1. 在原有的基础上加入springboot框架
2. 实现自己的注解类
3. 基于springboot框架实现注解类下的代码作用
4. 基于springboot实现消费者和提供者
5. 测试
